 笔记本 

 JavaScript权威指南（原书第6版） 

 (美)David Flanagan 

 Citation (APA): Flanagan, (. (2018). *JavaScript权威指南（原书第6版）* [Kindle Android version]. Retrieved from Amazon.com 

------

 第3章　类型、值和变量 

 标注 (黄色) -  位置 1428 

 JavaScript 的函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。有意思的是，这意味着变量在声明之前甚至已经可用。  JavaScript 的这个特性被非正式地称为声明提前（ hoisting ），即 JavaScript  函数里声明的所有变量（但不涉及赋值）都被“提前”至函数体的顶部 [12] ，看一下如下代码： 

 第4章　表达式和运算符 

 标注 (黄色) -  位置 1714 

 · 如果其中一个操作数是对象，则对象会遵循对象到原始值的转换规则转换为原始类值（参照 3.8.3 节）：日期对象通过 toString()  方法执行转换，其他对象则通过 valueOf() 方法执行转换（如果 valueOf() 方法返回一个原始值的话）。由于多数对象都不具备可用的  valueOf() 方法，因此它们会通过 toString() 方法来执行转换。 

 标注 (黄色) -  位置 1717 

 在进行了对象到原始值的转换后 

 标注 (黄色) -  位置 1718 

 如果其中一个操作数是字符串的话，另一个操作数也会转换为字符串，然后进行字符串连接。 · 否则，两个操作数都将转换为数字（或者 NaN ），然后进行加法操作。 

 标注 (黄色) -  位置 1728 

 1+2+"blind mice";//= ＞ "3 blind mice" 1+(2+"blind mice");//= ＞ "12 blind mice" 第一行没有圆 

 标注 (黄色) -  位置 1806 

 · 如果两个值类型不相同，则它们不相等。 · 如果两个值都是 null 或者都是 undefined ，则它们不相等。 · 如果两个值都是布尔值  true 或都是布尔值 false ，则它们相等。 · 如果其中一个值是 NaN ，或者两个值都是 NaN ，则它们不相等。 NaN  和其他任何值都是不相等的，包括它本身！通过 x!==x 来判断 x 是否为 NaN ，只有在 x 为 

 标注 (黄色) -  位置 1810 

 NaN 的时候，这个表达式的值才为 true 。 · 如果两个值为数字且数值相等，则它们相等。如果一个值为 0 ，另一个值为 -0  ，则它们同样相等。 · 如果两个值为字符串，且所含的对应位上的 16 位数（参照 3.2  节）完全相等，则它们相等。如果它们的长度或内容不同，则它们不等。两个字符串可能含义完全一样且所显示出的字符也一样，但具有不同编码的 16 位值。  JavaScript 并不对 Unicode 进行标准化的转换，因此像这样的字符串通过“===”和“==”运算符的比较结果也不相等。第三部分的  String.localeCompare() 提供了另外一种比较字符串的方法。 ·  如果两个引用值指向同一个对象、数组或函数，则它们是相等的。如果指向不同的对象，则它们是不等的，尽管两个对象具有完全一样的属性。 

 标注 (黄色) -  位置 1819 

 如果两个操作数的类型相同，则和上文所述的严格相等的比较规则一样。如果严格相等，那么比较结果为相等。如果它们不严格相等，则比较结果为不相等。 ·  如果两个操作数类型不同，“==”相等操作符也可能会认为它们相等。检测相等将会遵守如下规则和类型转换：—如果一个值是 null ，另一个是  undefined ，则它们相等。—如果一个值是数字，另一个是字符串，先将字符串转换为数字，然后使用转换后的值进行比较。—如果其中一个值是  true ，则将其转换为 1 再进行比较。如果其中一个值是 false ，则将其转换为 0  再进行比较。—如果一个值是对象，另一个值是数字或字符串，则使用 3.8.3 节所提到的转换规则将对象转换为原始值，然后再进行比较。对象通过  toString() 方法或者 valueOf() 方法转换为原始值。 JavaScript 

 标注 (黄色) -  位置 1856 

 对于数字和字符串操作符来说，加号运算符和比较运算符的行为都有所不同，前者更偏爱字符串，如果它的其中一个操作数是字符串的话，则进行字符串连接操作。而比较运算符则更偏爱数字，只有在两个操作数都是字符串的时候，才会进行字符串的比较： 

 标注 (黄色) -  位置 1859 

 1+2// 加法 . 结果是 3 "1"+"2"// 字符串连接，结果是 "12" "1"+2// 字符串链接， 2 转换为 "2" ，结果是  "12" 11 ＜ 3// 数字的比较，结果为 false "11" ＜ "3"// 字符串比较，结果为 true "11" ＜ 3//  数字的比较， "11" 转换为 11 ，结果为 false "one" ＜ 3// 数字的比较， "one" 转换为 NaN ，结果为  false 

 第8章　函数 

 标注 (黄色) -  位置 4401 

 从技术角度看，其实可以将这个闭包合并为属性存取器方法 getter 和 setter 。下面这段代码所示的 counter() 函数的版本是  6.6 节中代码的变种，所不同的是，这里私有状态的实现是利用了闭包，而不是利用普通的对象属性来实现： function  counter(n){// 函数参数 n 是一个私有变量 return{// 属性 getter 方法返回并给私有计数器 var 递增 1  get count(){return n++;},// 

 标注 (黄色) -  位置 4405 

 性 setter 不允许 n 递减 set count(m){ if(m ＞ =n)n=m; else throw Error("count  can only be set to a larger value"); } }; } var c=counter(1000);  c.count//= ＞ 1000 c.count//= ＞ 1001 c.count=2000 c.count//= ＞ 2000  c.count=2000//= ＞ Error! 

 笔记 -  位置 4413 

 感觉函数类型实际上是个类。方便实现闭包记录状态 

 标注 (黄色) -  位置 4496 

 call() 方法和 apply() 方法 

 笔记 -  位置 4497 

 有点std::bind日this的感觉 

 第9章　类和模块 

 标注 (黄色) -  位置 5089 

 首先，对于 Java 类的实例方法来说，实例字段可以用做局部变量，而不需要使用关键字 this 来引用它们。 JavaScript 是没办法模拟这个特性的，但可以使用 with 语句来近似地实现这个功能（但这种做法并不推荐 